//:: # Copyright 2013, Big Switch Networks, Inc.
//:: #
//:: # LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
//:: # the following special exception:
//:: #
//:: # LOXI Exception
//:: #
//:: # As a special exception to the terms of the EPL, you may distribute libraries
//:: # generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
//:: # that copyright and licensing notices generated by LoxiGen are not altered or removed
//:: # from the LoxiGen Libraries and the notice provided below is (i) included in
//:: # the LoxiGen Libraries, if distributed in source code form and (ii) included in any
//:: # documentation for the LoxiGen Libraries, if distributed in binary form.
//:: #
//:: # Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
//:: #
//:: # You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
//:: # a copy of the EPL at:
//:: #
//:: # http::: #www.eclipse.org/legal/epl-v10.html
//:: #
//:: # Unless required by applicable law or agreed to in writing, software
//:: # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//:: # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
//:: # EPL for the specific language governing permissions and limitations
//:: # under the EPL.
//::
//:: from loxi_ir import *
//:: import itertools
//:: import java_gen.java_model as java_model
//:: include('_copyright.java')

//:: include('_autogen.java')

package ${test.package};

//:: include("_imports.java", msg=msg)
import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.*;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;

import org.hamcrest.CoreMatchers;

@RunWith(Parameterized.class)
public class ${test.name} {
    //:: factory = java_model.model.factory_of(test.interface)
    //:: var_type = msg.interface.name
    //:: var_name = msg.interface.variable_name
    //:: use_builder = len(msg.data_members) > 0
    //:: factory_method = factory.method_name(msg.interface, builder=use_builder)
    //:: factory_impl = java_model.model.factory_of(test.interface).of_version(test.java_class.version).name
    ${factory.name if factory.name is not None else "OFFactory"} factory;

    final static byte[] ${msg.constant_name}_SERIALIZED =
        new byte[] { ${", ".join("%s0x%x" % (("" if ord(c)<128 else "(byte) "),  ord(c)) for c in test_data["binary"] ) } };


    private final static int[] PREFIX_BYTES = { 0, 1, 4, 255, 65335 };
    private final static byte[] EMPTY_BYTES = new byte[65535];

    private final OFMessageReader<?> messageReader;

    @Parameters(name="{index}.MessageReader={0}")
    public static Iterable<Object> data() {
        return ImmutableList.<Object>of(
                ${ ", ".join( "{}.READER".format(c.name) for c in msg.ancestor_classes) }
        );
    }

    public ${test.name}(OFMessageReader<?> messageReader) {
        this.messageReader = messageReader;
    }

    @Before
    public void setup() {
        factory = ${factory_impl + ".INSTANCE" if factory_impl is not None else "OFFactories.getFactory(OFVersion." + version.constant_version + ")"};
    }

    //:: if "java" in test_data:
    @Test
    public void testWrite() {
        //:: if use_builder:
        ${var_type}.Builder builder = factory.${factory_method}();
        ${test_data["java"]};
        ${var_type} ${var_name} = builder.build();
        //:: else:
        ${var_type} ${var_name} = factory.${factory_method}();
        //:: #endif
        ByteBuf bb = Unpooled.buffer();
        ${var_name}.writeTo(bb);
        byte[] written = new byte[bb.readableBytes()];
        bb.readBytes(written);

        assertThat(written, CoreMatchers.equalTo(${msg.constant_name}_SERIALIZED));
    }

   //:: else:
   // FIXME: No java stanza in test_data for this class. Add to support write test
   //:: #endif

    @Test
    public void testRead() throws Exception {
        ByteBuf input = Unpooled.copiedBuffer(${msg.constant_name}_SERIALIZED);

        Object ${var_name}Read = messageReader.readFrom(input);
        assertThat(${var_name}Read, CoreMatchers.instanceOf(${msg.name}.class));
    //:: if "java" in test_data:
        //:: if use_builder:
        ${var_type}.Builder builder = factory.${factory_method}();
        ${test_data["java"]};
        ${var_type} ${var_name}Built = builder.build();
        //:: else:
        ${var_type} ${var_name}Built = factory.${factory_method}();
        //:: #endif

        assertEquals(${msg.constant_name}_SERIALIZED.length, input.readerIndex());

        assertEquals(${var_name}Built, ${var_name}Read);
    //:: #else
        // FIXME: No java stanza in test_data for this class. Add to enable validation of read message
    //:: #endif
   }

    /**
     * Validates Reader handling of partial messages in the buffer.
     *
     * Ensures that readers deal with partially available messages, and that buffers
     * are returned unmodified. Also checks compatibility when the data is not at the start of
     * the buffer (readerIndex=0), but somewhere else (with the readerIndex appropriately set).
     */
   @Test
   public void testPartialRead() throws Exception {
       ByteBuf msgBuffer = Unpooled.copiedBuffer(${msg.constant_name}_SERIALIZED);
       for (int prefixLength: PREFIX_BYTES) {
           ByteBuf prefixBuffer = Unpooled.wrappedBuffer(EMPTY_BYTES).slice(0, prefixLength);
           ByteBuf wholeBuffer = Unpooled.wrappedBuffer(prefixBuffer, msgBuffer);
           for (int partialLength = 0; partialLength < ${msg.constant_name}_SERIALIZED.length - 1; partialLength++) {
               int length = prefixLength + partialLength;
               ByteBuf slice = wholeBuffer.slice(0, length);
               slice.readerIndex(prefixLength);

               Object read = messageReader.readFrom(slice);

               assertNull("partial message should not be read", read);
               assertEquals("Reader index should be back at the start", prefixLength, slice.readerIndex());
           }

       }
   }

   @Test
   public void testReadWrite() throws Exception {
       ByteBuf input = Unpooled.copiedBuffer(${msg.constant_name}_SERIALIZED);

       // FIXME should invoke the overall reader once implemented
       ${var_type} ${var_name} = (${var_type}) messageReader.readFrom(input);
       assertEquals(${msg.constant_name}_SERIALIZED.length, input.readerIndex());

       // write message again
       ByteBuf bb = Unpooled.buffer();
       ${var_name}.writeTo(bb);
       byte[] written = new byte[bb.readableBytes()];
       bb.readBytes(written);

       assertThat(written, CoreMatchers.equalTo(${msg.constant_name}_SERIALIZED));
   }

}
