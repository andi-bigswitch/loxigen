//:: # Copyright 2013, Big Switch Networks, Inc.
//:: #
//:: # LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
//:: # the following special exception:
//:: #
//:: # LOXI Exception
//:: #
//:: # As a special exception to the terms of the EPL, you may distribute libraries
//:: # generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
//:: # that copyright and licensing notices generated by LoxiGen are not altered or removed
//:: # from the LoxiGen Libraries and the notice provided below is (i) included in
//:: # the LoxiGen Libraries, if distributed in source code form and (ii) included in any
//:: # documentation for the LoxiGen Libraries, if distributed in binary form.
//:: #
//:: # Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
//:: #
//:: # You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
//:: # a copy of the EPL at:
//:: #
//:: # http::: #www.eclipse.org/legal/epl-v10.html
//:: #
//:: # Unless required by applicable law or agreed to in writing, software
//:: # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//:: # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
//:: # EPL for the specific language governing permissions and limitations
//:: # under the EPL.
//::
//:: from loxi_ir import *
//:: import os
//:: import itertools
//:: include('_copyright.java')

//:: include('_autogen.java')

package ${msg.package};

//:: include("_imports.java", msg=msg)

abstract class ${msg.name} {
    // version: ${version}
    final static byte WIRE_VERSION = ${version.int_version};
//:: if msg.is_fixed_length:
    final static int LENGTH = ${msg.length};
//:: else:
    final static int MINIMUM_LENGTH = ${msg.min_length};
//:: #endif


    public final static ${msg.name}.Reader READER = new Reader();

    static class Reader extends AbstractOFMessageReader<${msg.interface.inherited_declaration()}> {
        @Override
        public ${msg.interface.inherited_declaration()} readFrom(OFMessageReaderContext context, ByteBuf bb) throws OFParseError {
//:: if msg.is_fixed_length:
            if(bb.readableBytes() < LENGTH)
//:: else:
            if(bb.readableBytes() < MINIMUM_LENGTH)
//:: #endif
                return null;
            int start = bb.readerIndex();
//:: fields_with_length_member = {}
//:: length_field = None
//::    for prop in msg.members:
//::       if prop.is_virtual:
//::         continue
//::       elif prop.is_data:
            ${prop.java_type.skip_op(version,
                    length=fields_with_length_member[prop.c_name] if prop.c_name in fields_with_length_member else None)};
//:: elif prop.is_pad:
            // pad: ${prop.length} bytes
            bb.skipBytes(${prop.length});
//:: elif prop.is_fixed_value:
            // fixed value property ${prop.name} == ${prop.value}
            ${prop.java_type.priv_type} ${prop.name} = ${prop.java_type.read_op(version, pub_type=False)};
            if(${prop.name} != ${prop.priv_value})
                throw new OFParseError("Wrong ${prop.name}: Expected=${prop.enum_value}(${prop.value}), got="+${prop.name});
//:: elif prop.is_length_value:
            ${prop.java_type.public_type} ${prop.name} = ${prop.java_type.read_op(version, pub_type=True)};
            if(${prop.name} < MINIMUM_LENGTH)
                throw new OFParseError("Wrong ${prop.name}: Expected to be >= " + MINIMUM_LENGTH + ", was: " + ${prop.name});
            if( ( bb.readableBytes() + (bb.readerIndex() - start)) < ${prop.name} ) {
                // message not yet fully read
                bb.readerIndex(start);
                return null;
            }
//::     length_field = prop.name
//:: elif prop.is_field_length_value:
//::        fields_with_length_member[prop.member.field_name] = prop.name
            int ${prop.name} = ${prop.java_type.read_op(version)};
//:: elif prop.is_discriminator:
            ${prop.java_type.priv_type} ${prop.name} = ${prop.java_type.read_op(version, pub_type=False)};
            switch(${prop.name}) {
//::     for sub in msg.subclasses:
//::           if not model.generate_class(sub):
               // skip ${sub.name} - excluded from generation
//::           else:
//::           m = sub.member_by_name(prop.name)
//::           if not m.is_fixed_value:
//::                  raise Exception("subtype %s of %s does not have fixed value for discriminator %s" %
//::                           (sub.name, msg.name, prop.name))
//::           #endif
               case ${m.priv_value}:
                   bb.readerIndex(start);
                   // discriminator value ${m.enum_value}=${m.value} for class ${sub.name}
                   return ${sub.name}.READER.readFrom(context, bb);
//:: #endif    # generate_class
//:: #endfor
               default:
                   context.getUnparsedHandler().unparsedMessage(${msg.name}.class, "${prop.name}", ${prop.name});
            }
//:: #endif
//:: #endfor
            // will only reach here if the discriminator turns up nothing.
//::    if msg.ir_class.is_instanceof("of_oxm"):
//::        length_field = "length"
            // hack around for OXM's: they have their length stored as the 4th
            int oxmDataLength = typeLen & 0x0000_00FF;
            bb.skipBytes(oxmDataLength);
            return null;
//::    elif not msg.is_fixed_length and length_field == None:
                   // ${msg.name} is variable length, and length field not read before discriminator.
                   // Cannot carry on after parse error
            throw new OFParseError("Could not parse message ${prop.name} and length not known, so cannot be skipped");
//::    else:
            //:: if msg.is_fixed_length:
                skip = "LENGTH"
            //:: else:
            //::    if msg.align and not msg.length_includes_align:
            //::        skip = "(({} + {}) / {}) * {}".format(length_field, msg.align - 1, msg.align, msg.align)
            //::    else:
            //::        skip = length_field
            //::    #endif
            //:: #endif
            bb.skipBytes(${skip} - (bb.readerIndex() - start));
            return null;
//::    #endif
        }
    }
}
